name: ğŸ” Security Pipeline - ML Vulnerability Detection

on:
  pull_request:
    branches: [test]  # Solo se activa en PR hacia test
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write
  actions: write

env:
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}

jobs:
  security-analysis:
    name: ğŸ¤– ML Security Analysis
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: ğŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: ğŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'
      
      - name: ğŸ“¦ Install ML dependencies
        run: |
          cd ml-security/backend
          pip install -r requirements.txt
      
      - name: âœ… Verificar modelos ML
        run: |
          echo "ğŸ” Verificando modelos entrenados..."
          ls -lh ml-security/models/
          
          # Verificar que existan los modelos necesarios
          if [ ! -f ml-security/models/vulnerability_detector.pkl ]; then
            echo "âŒ Error: Modelo de detecciÃ³n no encontrado"
            exit 1
          fi
          
          if [ ! -f ml-security/models/cwe_classifier.pkl ]; then
            echo "âŒ Error: Modelo de clasificaciÃ³n CWE no encontrado"
            exit 1
          fi
          
          echo "âœ… Todos los modelos estÃ¡n disponibles"
          echo "ğŸ“Š MÃ©tricas del Modelo 1 (Detector):"
          cat ml-security/models/metrics_vulnerability_detector.txt
          echo ""
          echo "ğŸ“Š MÃ©tricas del Modelo 2 (Clasificador CWE):"
          cat ml-security/models/metrics_cwe_classifier.txt
      
      - name: ğŸ” Escanear vulnerabilidades con ML
        id: scan
        continue-on-error: true
        run: |
          echo "ğŸ” Escaneando cÃ³digo con modelos ML..."
          echo "ğŸ“Š Modelo 1: Detector binario (79.01% accuracy, 90.12% recall)"
          echo "ğŸ“Š Modelo 2: Clasificador CWE (86.94% accuracy)"
          echo ""
          
          # Instalar dependencias para el script
          pip install requests numpy scikit-learn
          
          # Verificar que existan los modelos
          echo "ğŸ” Verificando modelos ML..."
          ls -lh ml-security/models/*.pkl || { 
            echo "âŒ No se encontraron modelos ML necesarios"
            echo "scan_status=failed" >> $GITHUB_OUTPUT
            echo "vulnerable=unknown" >> $GITHUB_OUTPUT
            exit 1
          }
          
          # Hacer ejecutable el script
          chmod +x .github/scripts/scan_vulnerabilities.py
          
          # Escanear directorios especÃ­ficos
          echo "ğŸ” Escaneando cliente y servidor..."
          
          # Intentar escaneo con el script de Python
          SCAN_SUCCESS=0
          python .github/scripts/scan_vulnerabilities.py cliente 2>&1 | tee scan_output_cliente.txt || true
          python .github/scripts/scan_vulnerabilities.py servidor 2>&1 | tee scan_output_servidor.txt || true
          
          # Verificar que se haya generado el reporte
          if [ -f "vulnerability_report.json" ]; then
            echo "âœ… Reporte generado exitosamente"
            
            # Copiar a ubicaciÃ³n esperada para notificaciÃ³n
            cp vulnerability_report.json security_report.json || true
            
            # Mostrar contenido del reporte
            echo "ğŸ“„ Contenido del reporte:"
            cat vulnerability_report.json
            
            # Verificar vulnerabilidades
            if grep -q '"is_safe": false' vulnerability_report.json; then
              echo "vulnerable=true" >> $GITHUB_OUTPUT
              echo "scan_status=completed" >> $GITHUB_OUTPUT
              echo "âŒ Se detectaron vulnerabilidades"
              exit 1
            else
              echo "vulnerable=false" >> $GITHUB_OUTPUT
              echo "scan_status=completed" >> $GITHUB_OUTPUT
              echo "âœ… CÃ³digo seguro - Sin vulnerabilidades detectadas"
            fi
          else
            echo "scan_status=failed" >> $GITHUB_OUTPUT
            echo "vulnerable=unknown" >> $GITHUB_OUTPUT
            echo "âŒ Error: No se pudo generar el reporte de seguridad"
            cat scan_output_cliente.txt scan_output_servidor.txt || true
            exit 1
          fi
      
      - name: ğŸ“¤ Upload security report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-report
          path: security_report.json
          retention-days: 30
      
      - name: ğŸ“± Enviar notificaciÃ³n a Telegram
        if: always()
        run: |
          pip install requests
          python .github/scripts/notify_telegram.py || echo "âš ï¸  Error enviando notificaciÃ³n"
      
      - name: ğŸ“Š Comment PR with results
        if: always() && steps.scan.outputs.scan_status == 'completed'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Intentar leer el reporte
            let report;
            try {
              if (fs.existsSync('vulnerability_report.json')) {
                report = JSON.parse(fs.readFileSync('vulnerability_report.json', 'utf8'));
              } else if (fs.existsSync('security_report.json')) {
                report = JSON.parse(fs.readFileSync('security_report.json', 'utf8'));
              } else {
                throw new Error('Reporte no encontrado');
              }
            } catch (error) {
              // Si no hay reporte, crear comentario de error
              const errorBody = `## âŒ Error en AnÃ¡lisis de Seguridad\n\n` +
                `No se pudo completar el anÃ¡lisis ML.\n\n` +
                `**Error:** ${error.message}\n\n` +
                `Por favor, revisa los logs del workflow para mÃ¡s detalles.`;
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: errorBody
              });
              return;
            }
            
            const status = report.is_safe ? 'âœ… APROBADO' : 'âŒ RECHAZADO';
            const emoji = report.is_safe ? 'ğŸŸ¢' : 'ğŸ”´';
            
            let body = `## ${emoji} AnÃ¡lisis de Seguridad ML - ${status}\n\n`;
            body += `ğŸ¤– **Modelos ML Utilizados:**\n`;
            body += `- Detector Binario de Vulnerabilidades (Accuracy: 79.01%)\n`;
            body += `- Clasificador de CWE (Accuracy: 86.94%)\n\n`;
            body += `ğŸ“Š **Resultados del AnÃ¡lisis:**\n`;
            body += `- Total de archivos analizados: ${report.summary.total || 0}\n`;
            body += `- Archivos seguros: ${report.summary.safe || 0}\n`;
            body += `- Archivos vulnerables: ${report.summary.vulnerable || 0}\n\n`;
            
            if (!report.is_safe && report.vulnerabilities && report.vulnerabilities.length > 0) {
              body += `### ğŸš¨ Vulnerabilidades Detectadas por ML:\n\n`;
              const vulns = report.vulnerabilities.slice(0, 10);
              vulns.forEach((vuln, idx) => {
                body += `**${idx + 1}. ${vuln.type || 'Unknown'}**\n`;
                body += `- Archivo: \`${vuln.file}\`\n`;
                body += `- LÃ­nea: ${vuln.line}\n`;
                body += `- Confianza: ${(vuln.confidence * 100).toFixed(1)}%\n`;
                if (vuln.code) {
                  body += `- CÃ³digo: \`${vuln.code.substring(0, 40)}...\`\n`;
                }
                body += `\n`;
              });
              if (report.vulnerabilities.length > 10) {
                body += `... y ${report.vulnerabilities.length - 10} vulnerabilidades mÃ¡s\n\n`;
              }
              body += `âš ï¸ **AcciÃ³n requerida:** Corregir las vulnerabilidades detectadas por el modelo ML antes de hacer merge.\n`;
              body += `ğŸ’¡ Los modelos ML han identificado patrones de cÃ³digo inseguro con alta confianza.\n`;
            } else {
              body += `### âœ… CÃ³digo Seguro Validado por ML\n\n`;
              body += `âœ¨ El anÃ¡lisis con modelos de Machine Learning no detectÃ³ vulnerabilidades conocidas.\n\n`;
              body += `ğŸ” **Verificaciones realizadas:**\n`;
              body += `- AnÃ¡lisis binario de seguridad (Detector de Vulnerabilidades)\n`;
              body += `- ClasificaciÃ³n de patrones CWE (Clasificador de Weaknesses)\n`;
              body += `- ValidaciÃ³n de ${report.summary.total || 0} archivo(s) de cÃ³digo\n\n`;
              body += `âœ… El cÃ³digo estÃ¡ listo para merge segÃºn los criterios de seguridad ML.\n`;
            }
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
      
      - name: ğŸ“± Send Telegram notification - Vulnerable
        if: steps.scan.outputs.vulnerable == 'true'
        run: |
          # Extraer estadÃ­sticas del reporte
          TOTAL=$(jq -r '.summary.total // .total_files // 0' security_report.json)
          SAFE=$(jq -r '.summary.safe // .secure_files // 0' security_report.json)
          VULNERABLE=$(jq -r '.summary.vulnerable // .vulnerable_files // 0' security_report.json)
          
          # Extraer archivos vulnerables (primeros 3)
          VULN_FILES=$(jq -r '.vulnerable_list[0:3] | .[] | "  â€¢ " + (.file | split("/") | .[-1]) + " (" + (.cwe_type // "Unknown") + ")"' security_report.json | tr '\n' '%0A' || echo "  â€¢ Ver detalles en el PR")
          
          MESSAGE="ğŸ”´ <b>ALERTA DE SEGURIDAD</b>%0A%0A"
          MESSAGE+="ğŸ“¦ <b>Repositorio:</b> ${{ github.repository }}%0A"
          MESSAGE+="ğŸ”€ <b>PR:</b> #${{ github.event.pull_request.number }}%0A"
          MESSAGE+="ğŸ‘¤ <b>Autor:</b> ${{ github.event.pull_request.user.login }}%0A"
          MESSAGE+="ğŸŒ¿ <b>Rama:</b> ${{ github.head_ref }} â†’ ${{ github.base_ref }}%0A%0A"
          MESSAGE+="ğŸ¤– <b>AnÃ¡lisis ML Completado:</b>%0A"
          MESSAGE+="  â€¢ Modelo 1: Detector Binario (79% accuracy)%0A"
          MESSAGE+="  â€¢ Modelo 2: Clasificador CWE (87% accuracy)%0A%0A"
          MESSAGE+="ğŸ“Š <b>Resultados del Escaneo:</b>%0A"
          MESSAGE+="  â€¢ Total archivos: ${TOTAL}%0A"
          MESSAGE+="  â€¢ Archivos seguros: ${SAFE}%0A"
          MESSAGE+="  â€¢ ğŸš¨ Vulnerabilidades: ${VULNERABLE}%0A%0A"
          MESSAGE+="ğŸ”´ <b>Archivos Vulnerables:</b>%0A"
          MESSAGE+="${VULN_FILES}%0A%0A"
          MESSAGE+="âš ï¸ <b>ACCIÃ“N REQUERIDA:</b>%0A"
          MESSAGE+="El cÃ³digo NO puede ser mergeado.%0A"
          MESSAGE+="Corregir vulnerabilidades antes de continuar.%0A%0A"
          MESSAGE+="ğŸ”— <a href='${{ github.event.pull_request.html_url }}'>Ver Reporte Completo</a>"
          
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML"
      
      - name: ğŸ“± Send Telegram notification - Scan Failed
        if: steps.scan.outputs.scan_status == 'failed'
        run: |
          MESSAGE="âš ï¸ ERROR EN ANÃLISIS DE SEGURIDAD%0A%0A"
          MESSAGE+="Repositorio: ${{ github.repository }}%0A"
          MESSAGE+="PR: #${{ github.event.pull_request.number }}%0A"
          MESSAGE+="Autor: ${{ github.event.pull_request.user.login }}%0A"
          MESSAGE+="Rama: ${{ github.head_ref }} â†’ ${{ github.base_ref }}%0A%0A"
          MESSAGE+="âŒ El escaneo de seguridad fallÃ³%0A"
          MESSAGE+="No se pudo generar el reporte de seguridad.%0A%0A"
          MESSAGE+="ğŸ”§ AcciÃ³n requerida:%0A"
          MESSAGE+="- Revisar logs del workflow%0A"
          MESSAGE+="- Verificar que los modelos ML estÃ©n presentes%0A"
          MESSAGE+="- Contactar al administrador si persiste%0A%0A"
          MESSAGE+="Ver logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML"
      
      - name: ğŸ“± Send Telegram notification - Safe
        if: steps.scan.outputs.vulnerable == 'false'
        run: |
          # Extraer estadÃ­sticas del reporte
          TOTAL=$(jq -r '.summary.total // .total_files // 0' security_report.json)
          SAFE=$(jq -r '.summary.safe // .secure_files // 0' security_report.json)
          VULNERABLE=$(jq -r '.summary.vulnerable // .vulnerable_files // 0' security_report.json)
          
          MESSAGE="âœ… <b>CÃ“DIGO SEGURO</b>%0A%0A"
          MESSAGE+="ğŸ“¦ <b>Repositorio:</b> ${{ github.repository }}%0A"
          MESSAGE+="ğŸ”€ <b>PR:</b> #${{ github.event.pull_request.number }}%0A"
          MESSAGE+="ğŸ‘¤ <b>Autor:</b> ${{ github.event.pull_request.user.login }}%0A"
          MESSAGE+="ğŸŒ¿ <b>Rama:</b> ${{ github.head_ref }} â†’ ${{ github.base_ref }}%0A%0A"
          MESSAGE+="ğŸ¤– <b>AnÃ¡lisis ML Completado:</b>%0A"
          MESSAGE+="  â€¢ Modelo 1: Detector Binario (79% accuracy)%0A"
          MESSAGE+="  â€¢ Modelo 2: Clasificador CWE (87% accuracy)%0A%0A"
          MESSAGE+="ğŸ“Š <b>Resultados del Escaneo:</b>%0A"
          MESSAGE+="  â€¢ Total archivos: ${TOTAL}%0A"
          MESSAGE+="  â€¢ Archivos seguros: ${SAFE}%0A"
          MESSAGE+="  â€¢ Vulnerabilidades: ${VULNERABLE}%0A%0A"
          MESSAGE+="âœ… <b>ConclusiÃ³n:</b> No se detectaron vulnerabilidades%0A"
          MESSAGE+="ğŸš€ El cÃ³digo puede continuar al siguiente stage%0A%0A"
          MESSAGE+="ğŸ”— <a href='${{ github.event.pull_request.html_url }}'>Ver Pull Request</a>"
          
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML"
      
      - name: ğŸš¨ Create issue for vulnerabilities
        if: steps.scan.outputs.vulnerable == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = JSON.parse(fs.readFileSync('ml-security/security_report.json', 'utf8'));
            
            let body = `## ğŸ”´ Vulnerabilidades Detectadas por ML\n\n`;
            body += `**Pull Request:** #${{ github.event.pull_request.number }}\n`;
            body += `**Autor:** @${{ github.event.pull_request.user.login }}\n`;
            body += `**Rama:** ${{ github.head_ref }} â†’ ${{ github.base_ref }}\n\n`;
            body += `### ğŸ“Š Resumen\n`;
            body += `- Archivos vulnerables: ${report.vulnerable_files}\n`;
            body += `- Total de archivos: ${report.total_files}\n\n`;
            body += `### ğŸš¨ Archivos Afectados\n\n`;
            
            report.vulnerable_list.forEach((vuln, idx) => {
              body += `${idx + 1}. **${vuln.file}**\n`;
              body += `   - Confianza: ${(vuln.confidence * 100).toFixed(1)}%\n`;
              if (vuln.issues) {
                vuln.issues.forEach(issue => {
                  body += `   - ${issue}\n`;
                });
              }
              body += `\n`;
            });
            
            body += `### âš ï¸ AcciÃ³n Requerida\n`;
            body += `1. Revisar y corregir las vulnerabilidades detectadas\n`;
            body += `2. Actualizar el Pull Request con los cambios\n`;
            body += `3. El pipeline volverÃ¡ a ejecutarse automÃ¡ticamente\n\n`;
            body += `---\n`;
            body += `ğŸ¤– Detectado por: ML Vulnerability Scanner (Random Forest)\n`;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ğŸ”´ Vulnerabilidades en PR #${{ github.event.pull_request.number }}`,
              body: body,
              labels: ['security', 'vulnerability', 'automated']
            });
      
      - name: ğŸ·ï¸ Add label - Scan Failed
        if: steps.scan.outputs.scan_status == 'failed'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['scan-failed', 'needs-attention']
            });
      
      - name: ğŸ·ï¸ Add label - Vulnerable
        if: steps.scan.outputs.vulnerable == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['vulnerable', 'security-issue']
            });
      
      - name: âŒ Fail if vulnerable or scan failed
        if: steps.scan.outputs.vulnerable == 'true' || steps.scan.outputs.scan_status == 'failed'
        run: |
          if [ "${{ steps.scan.outputs.scan_status }}" == "failed" ]; then
            echo "âŒ Escaneo de seguridad fallÃ³ - Pipeline bloqueado"
            echo "No se pudo completar el anÃ¡lisis ML"
          else
            echo "âŒ Vulnerabilidades detectadas - Pipeline fallido"
            echo "El cÃ³digo NO puede ser mergeado"
          fi
          exit 1

  auto-merge-to-test:
    name: ğŸ”€ Auto Merge to Test
    needs: [security-analysis]
    runs-on: ubuntu-latest
    if: success() && github.base_ref == 'test'
    permissions:
      contents: write
      pull-requests: write
      actions: write
    
    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: ğŸ”€ Auto merge PR
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            
            try {
              // Intentar hacer merge automÃ¡tico
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                commit_title: `ğŸ”€ Auto-merge: ${pr.title}`,
                commit_message: `CÃ³digo aprobado por anÃ¡lisis ML de seguridad.\n\nâœ… Sin vulnerabilidades detectadas\nâœ… Listo para pruebas en rama test`,
                merge_method: 'merge'
              });
              
              console.log('âœ… PR mergeado automÃ¡ticamente a test');
              
              // Agregar comentario
              await github.rest.issues.createComment({
                issue_number: pr.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: 'ğŸ¤– **Merge automÃ¡tico realizado**\n\nâœ… CÃ³digo aprobado por anÃ¡lisis ML de seguridad\nğŸš€ Ahora se ejecutarÃ¡n las pruebas automÃ¡ticas en la rama `test`'
              });
              
            } catch (error) {
              console.log('âš ï¸ No se pudo hacer merge automÃ¡tico:', error.message);
              core.setFailed('Error en merge automÃ¡tico: ' + error.message);
            }
      
      - name: ğŸ“± Notificar merge exitoso e inicio de tests
        if: success()
        run: |
          MESSAGE="ğŸ”€ <b>MERGE AUTOMÃTICO EXITOSO</b>%0A%0A"
          MESSAGE+="ğŸ“¦ <b>Repositorio:</b> ${{ github.repository }}%0A"
          MESSAGE+="ğŸ”€ <b>PR:</b> #${{ github.event.pull_request.number }}%0A"
          MESSAGE+="ğŸ‘¤ <b>Autor:</b> ${{ github.event.pull_request.user.login }}%0A"
          MESSAGE+="ğŸŒ¿ <b>Rama:</b> ${{ github.head_ref }} â†’ test%0A%0A"
          MESSAGE+="âœ… <b>CÃ³digo aprobado por ML</b>%0A"
          MESSAGE+="ğŸ§ª <b>Siguiente etapa:</b> Iniciando pruebas automÃ¡ticas...%0A%0A"
          MESSAGE+="ğŸ“ <b>Tests a ejecutar:</b>%0A"
          MESSAGE+="  â€¢ Tests del servidor (Jest)%0A"
          MESSAGE+="  â€¢ Tests del cliente (Jest)%0A%0A"
          MESSAGE+="â³ <b>Estado:</b> Ejecutando tests...%0A%0A"
          MESSAGE+="ğŸ”— <a href='${{ github.event.pull_request.html_url }}'>Ver Pull Request</a>"
          
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML"
      
      - name: ğŸ§ª Disparar test-pipeline
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'test-pipeline.yml',
              ref: 'test'
            });
            console.log('âœ… Test pipeline disparado');
      
      - name: ğŸ“± Notificar error en merge
        if: failure()
        run: |
          MESSAGE="âŒ <b>ERROR EN MERGE AUTOMÃTICO</b>%0A%0A"
          MESSAGE+="ğŸ“¦ <b>Repositorio:</b> ${{ github.repository }}%0A"
          MESSAGE+="ğŸ”€ <b>PR:</b> #${{ github.event.pull_request.number }}%0A"
          MESSAGE+="ğŸŒ¿ <b>Rama:</b> ${{ github.head_ref }} â†’ test%0A%0A"
          MESSAGE+="âš ï¸ No se pudo completar el merge automÃ¡tico%0A"
          MESSAGE+="ğŸ” Revisar posibles conflictos%0A%0A"
          MESSAGE+="ğŸ”— <a href='${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'>Ver Logs</a>"
          
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML"
