name: Vulnerability Detection Pipeline

on:
  pull_request:
    branches: [ test ]
    types: [opened, synchronize, reopened]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  vulnerability-scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: üêç Configurar Python 3.10
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        cache: 'pip'
    
    - name: üì¶ Instalar dependencias
      run: |
        python -m pip install --upgrade pip
        pip install scikit-learn pandas numpy requests
    
    - name: üì• Descargar modelos entrenados
      run: |
        mkdir -p models
        # Copiar modelos si existen en ml-security/models
        if [ -d "ml-security/models" ]; then
          echo "üìã Copiando modelos desde ml-security/models..."
          cp ml-security/models/*.pkl models/ 2>/dev/null || echo "‚ö†Ô∏è Algunos modelos no se encontraron"
          ls -lah models/
        else
          echo "‚ö†Ô∏è Directorio ml-security/models no existe"
        fi
    
    - name: üîç Analizar c√≥digo con modelo ML
      run: |
        python .github/scripts/scan_vulnerabilities.py
      continue-on-error: true
    
    - name: üìä Publicar reporte de vulnerabilidades
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: vulnerability-report
        path: vulnerability_report.json
        retention-days: 30
    
    - name: üí¨ Comentar en PR
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          try {
            const report = JSON.parse(fs.readFileSync('vulnerability_report.json', 'utf8'));
            
            if (report.vulnerabilities.length > 0) {
              let comment = '## ‚ö†Ô∏è Vulnerabilidades Detectadas\n\n';
              report.vulnerabilities.forEach((vuln, idx) => {
                comment += `### ${idx + 1}. ${vuln.file}\n`;
                comment += `- **Tipo**: ${vuln.type}\n`;
                comment += `- **Confianza**: ${(vuln.confidence * 100).toFixed(1)}%\n`;
                comment += `- **L√≠nea**: ${vuln.line || 'N/A'}\n\n`;
              });
              comment += `**Total vulnerabilidades detectadas**: ${report.vulnerabilities.length}`;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } else {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: '‚úÖ No se detectaron vulnerabilidades en este PR'
              });
            }
          } catch (error) {
            console.log('‚ö†Ô∏è No se pudo procesar el reporte:', error);
          }
    
    - name: üîç Verificar configuraci√≥n de Telegram
      run: |
        if [ -z "$TELEGRAM_BOT_TOKEN" ]; then
          echo "‚ùå TELEGRAM_BOT_TOKEN no configurado"
        else
          echo "‚úÖ TELEGRAM_BOT_TOKEN configurado"
        fi
        if [ -z "$TELEGRAM_CHAT_ID" ]; then
          echo "‚ùå TELEGRAM_CHAT_ID no configurado"
        else
          echo "‚úÖ TELEGRAM_CHAT_ID configurado"
        fi
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      continue-on-error: true
    
    - name: üì± Notificar vulnerabilidades a Telegram
      if: always()
      run: python .github/scripts/notify_telegram.py
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        GITHUB_COMMIT_MESSAGE: ${{ github.event.pull_request.title || 'Sin mensaje' }}
        GITHUB_ACTOR: ${{ github.actor }}
      continue-on-error: true
    
    - name: ‚ùå Fallar si hay cualquier vulnerabilidad
      id: check_vuln
      run: python .github/scripts/check_vulnerabilities.py
      continue-on-error: true
    
    - name: üè∑Ô∏è Agregar etiqueta si hay vulnerabilidades
      if: steps.check_vuln.outcome == 'failure'
      uses: actions/github-script@v7
      with:
        script: |
          try {
            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['fixing-required']
            });
          } catch (error) {
            console.log('Could not add label:', error);
          }
    
    - name: üêõ Crear issue si hay vulnerabilidades
      if: steps.check_vuln.outcome == 'failure'
      uses: actions/github-script@v7
      with:
        script: |
          try {
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üîí Vulnerabilidades detectadas - Acci√≥n requerida',
              body: 'Se detectaron vulnerabilidades en el an√°lisis de seguridad. Por favor, revisa el PR y corrige los problemas encontrados.',
              labels: ['security', 'fixing-required']
            });
          } catch (error) {
            console.log('Could not create issue:', error);
          }
    
    - name: ‚úÖ Auto-merge si pasa seguridad
      if: steps.check_vuln.outcome == 'success'
      uses: actions/github-script@v7
      with:
        script: |
          try {
            const prNumber = context.payload.pull_request.number;
            console.log('PR number:', prNumber);
            
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'squash'
            });
            
            console.log('‚úÖ PR mergeado autom√°ticamente a test');
          } catch (error) {
            console.log('Could not merge PR:', error);
          }
    
    - name: üí¨ Comentar resultado en PR
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          let comment = '';
          try {
            const report = JSON.parse(fs.readFileSync('vulnerability_report.json', 'utf8'));
            if (report.vulnerabilities.length === 0) {
              comment = '## ‚úÖ Security Analysis Passed\n\nNo vulnerabilities detected.';
            } else {
              comment = '## üö® Security Analysis Failed\n\n**Vulnerabilities Detected:** ' + report.vulnerabilities.length;
            }
          } catch (error) {
            comment = '‚ö†Ô∏è Could not process security analysis results';
          }
          if (comment) {
            const prNumber = context.payload.pull_request.number;
            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }


