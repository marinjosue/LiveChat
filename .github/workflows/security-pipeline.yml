name: üîê Security Pipeline - ML Vulnerability Detection

on:
  pull_request:
    branches: [test, main]
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write

env:
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}

jobs:
  security-analysis:
    name: ü§ñ ML Security Analysis
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: üêç Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: üì¶ Install ML dependencies
        run: |
          cd ml-security/backend
          pip install -r requirements.txt
      
      - name: ‚úÖ Verificar modelos ML
        run: |
          echo "üîç Verificando modelos entrenados..."
          ls -lh ml-security/models/
          
          # Verificar que existan los modelos necesarios
          if [ ! -f ml-security/models/vulnerability_detector.pkl ]; then
            echo "‚ùå Error: Modelo de detecci√≥n no encontrado"
            exit 1
          fi
          
          if [ ! -f ml-security/models/cwe_classifier.pkl ]; then
            echo "‚ùå Error: Modelo de clasificaci√≥n CWE no encontrado"
            exit 1
          fi
          
          echo "‚úÖ Todos los modelos est√°n disponibles"
          echo "üìä M√©tricas del Modelo 1 (Detector):"
          cat ml-security/models/metrics_vulnerability_detector.txt
          echo ""
          echo "üìä M√©tricas del Modelo 2 (Clasificador CWE):"
          cat ml-security/models/metrics_cwe_classifier.txt
      
      - name: üîç Escanear vulnerabilidades con ML
        id: scan
        continue-on-error: true
        run: |
          echo "üîç Escaneando c√≥digo con modelos ML..."
          echo "üìä Modelo 1: Detector binario (79.01% accuracy, 90.12% recall)"
          echo "üìä Modelo 2: Clasificador CWE (86.94% accuracy)"
          echo ""
          
          # Instalar dependencias para el script
          pip install requests
          
          # Hacer ejecutable el script
          chmod +x .github/scripts/scan_vulnerabilities.py
          
          # Escanear y generar reporte en la ra√≠z
          echo "üîç Analizando proyecto completo..."
          python .github/scripts/scan_vulnerabilities.py . || SCAN_FAILED=1
          
          # Verificar que se haya generado el reporte
          if [ -f "security_report.json" ]; then
            # Mover a la ubicaci√≥n esperada
            cp security_report.json ml-security/security_report.json
            
            # Verificar vulnerabilidades
            if grep -q '"is_safe": false' security_report.json; then
              echo "vulnerable=true" >> $GITHUB_OUTPUT
              echo "scan_status=completed" >> $GITHUB_OUTPUT
              echo "‚ùå Se detectaron vulnerabilidades"
              exit 1
            else
              echo "vulnerable=false" >> $GITHUB_OUTPUT
              echo "scan_status=completed" >> $GITHUB_OUTPUT
              echo "‚úÖ C√≥digo seguro - Sin vulnerabilidades detectadas"
            fi
          else
            echo "scan_status=failed" >> $GITHUB_OUTPUT
            echo "vulnerable=unknown" >> $GITHUB_OUTPUT
            echo "‚ùå Error: No se pudo generar el reporte de seguridad"
            exit 1
          fi
      
      - name: üì§ Upload security report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-report
          path: security_report.json
          retention-days: 30
      
      - name: üì± Enviar notificaci√≥n a Telegram
        if: always()
        run: |
          pip install requests
          python .github/scripts/telegram_notify.py vulnerability_scan security_report.json || echo "‚ö†Ô∏è  Error enviando notificaci√≥n"
      
      - name: üìä Comment PR with results
        if: always() && steps.scan.outputs.scan_status == 'completed'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Intentar leer el reporte
            let report;
            try {
              if (fs.existsSync('security_report.json')) {
                report = JSON.parse(fs.readFileSync('security_report.json', 'utf8'));
              } else if (fs.existsSync('ml-security/security_report.json')) {
                report = JSON.parse(fs.readFileSync('ml-security/security_report.json', 'utf8'));
              } else {
                throw new Error('Reporte no encontrado');
              }
            } catch (error) {
              // Si no hay reporte, crear comentario de error
              const errorBody = `## ‚ùå Error en An√°lisis de Seguridad\n\n` +
                `No se pudo completar el an√°lisis ML.\n\n` +
                `**Error:** ${error.message}\n\n` +
                `Por favor, revisa los logs del workflow para m√°s detalles.`;
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: errorBody
              });
              return;
            }
            
            const status = report.is_safe ? '‚úÖ APROBADO' : '‚ùå RECHAZADO';
            const emoji = report.is_safe ? 'üü¢' : 'üî¥';
            
            let body = `## ${emoji} An√°lisis de Seguridad ML - ${status}\n\n`;
            body += `üìä **Resumen:**\n`;
            body += `- Total de archivos: ${report.total_files}\n`;
            body += `- Archivos seguros: ${report.secure_files}\n`;
            body += `- Archivos vulnerables: ${report.vulnerable_files}\n\n`;
            
            if (!report.is_safe) {
              body += `### üö® Vulnerabilidades Detectadas:\n\n`;
              report.vulnerable_list.forEach(vuln => {
                body += `#### üìÑ ${vuln.file}\n`;
                body += `- **Confianza:** ${(vuln.confidence * 100).toFixed(1)}%\n`;
                if (vuln.issues) {
                  vuln.issues.forEach(issue => {
                    body += `- ${issue}\n`;
                  });
                }
                body += `\n`;
              });
              body += `\n‚ö†Ô∏è **Acci√≥n requerida:** Corregir las vulnerabilidades antes de hacer merge.\n`;
            } else {
              body += `### ‚úÖ C√≥digo Seguro\n\n`;
              body += `El an√°lisis ML no detect√≥ vulnerabilidades. El c√≥digo est√° listo para merge.\n`;
            }
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
      
      - name: üì± Send Telegram notification - Vulnerable
        if: steps.scan.outputs.vulnerable == 'true'
        run: |
          MESSAGE="üî¥ ALERTA DE SEGURIDAD%0A%0A"
          MESSAGE+="Repositorio: ${{ github.repository }}%0A"
          MESSAGE+="PR: #${{ github.event.pull_request.number }}%0A"
          MESSAGE+="Autor: ${{ github.event.pull_request.user.login }}%0A"
          MESSAGE+="Rama: ${{ github.head_ref }} ‚Üí ${{ github.base_ref }}%0A%0A"
          MESSAGE+="‚ùå VULNERABILIDADES DETECTADAS%0A"
          MESSAGE+="El c√≥digo NO puede ser mergeado hasta que se corrijan las vulnerabilidades.%0A%0A"
          MESSAGE+="Ver reporte: ${{ github.event.pull_request.html_url }}"
          
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML"
      
      - name: üì± Send Telegram notification - Scan Failed
        if: steps.scan.outputs.scan_status == 'failed'
        run: |
          MESSAGE="‚ö†Ô∏è ERROR EN AN√ÅLISIS DE SEGURIDAD%0A%0A"
          MESSAGE+="Repositorio: ${{ github.repository }}%0A"
          MESSAGE+="PR: #${{ github.event.pull_request.number }}%0A"
          MESSAGE+="Autor: ${{ github.event.pull_request.user.login }}%0A"
          MESSAGE+="Rama: ${{ github.head_ref }} ‚Üí ${{ github.base_ref }}%0A%0A"
          MESSAGE+="‚ùå El escaneo de seguridad fall√≥%0A"
          MESSAGE+="No se pudo generar el reporte de seguridad.%0A%0A"
          MESSAGE+="üîß Acci√≥n requerida:%0A"
          MESSAGE+="- Revisar logs del workflow%0A"
          MESSAGE+="- Verificar que los modelos ML est√©n presentes%0A"
          MESSAGE+="- Contactar al administrador si persiste%0A%0A"
          MESSAGE+="Ver logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML"
      
      - name: üì± Send Telegram notification - Safe
        if: steps.scan.outputs.vulnerable == 'false'
        run: |
          MESSAGE="‚úÖ C√ìDIGO SEGURO%0A%0A"
          MESSAGE+="Repositorio: ${{ github.repository }}%0A"
          MESSAGE+="PR: #${{ github.event.pull_request.number }}%0A"
          MESSAGE+="Autor: ${{ github.event.pull_request.user.login }}%0A"
          MESSAGE+="Rama: ${{ github.head_ref }} ‚Üí ${{ github.base_ref }}%0A%0A"
          MESSAGE+="‚úÖ El an√°lisis ML no detect√≥ vulnerabilidades.%0A"
          MESSAGE+="El c√≥digo puede continuar al siguiente stage.%0A%0A"
          MESSAGE+="Ver PR: ${{ github.event.pull_request.html_url }}"
          
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML"
      
      - name: üö® Create issue for vulnerabilities
        if: steps.scan.outputs.vulnerable == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = JSON.parse(fs.readFileSync('ml-security/security_report.json', 'utf8'));
            
            let body = `## üî¥ Vulnerabilidades Detectadas por ML\n\n`;
            body += `**Pull Request:** #${{ github.event.pull_request.number }}\n`;
            body += `**Autor:** @${{ github.event.pull_request.user.login }}\n`;
            body += `**Rama:** ${{ github.head_ref }} ‚Üí ${{ github.base_ref }}\n\n`;
            body += `### üìä Resumen\n`;
            body += `- Archivos vulnerables: ${report.vulnerable_files}\n`;
            body += `- Total de archivos: ${report.total_files}\n\n`;
            body += `### üö® Archivos Afectados\n\n`;
            
            report.vulnerable_list.forEach((vuln, idx) => {
              body += `${idx + 1}. **${vuln.file}**\n`;
              body += `   - Confianza: ${(vuln.confidence * 100).toFixed(1)}%\n`;
              if (vuln.issues) {
                vuln.issues.forEach(issue => {
                  body += `   - ${issue}\n`;
                });
              }
              body += `\n`;
            });
            
            body += `### ‚ö†Ô∏è Acci√≥n Requerida\n`;
            body += `1. Revisar y corregir las vulnerabilidades detectadas\n`;
            body += `2. Actualizar el Pull Request con los cambios\n`;
            body += `3. El pipeline volver√° a ejecutarse autom√°ticamente\n\n`;
            body += `---\n`;
            body += `ü§ñ Detectado por: ML Vulnerability Scanner (Random Forest)\n`;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üî¥ Vulnerabilidades en PR #${{ github.event.pull_request.number }}`,
              body: body,
              labels: ['security', 'vulnerability', 'automated']
            });
      
      - name: üè∑Ô∏è Add label - Scan Failed
        if: steps.scan.outputs.scan_status == 'failed'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['scan-failed', 'needs-attention']
            });
      
      - name: üè∑Ô∏è Add label - Vulnerable
        if: steps.scan.outputs.vulnerable == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['vulnerable', 'security-issue']
            });
      
      - name: ‚ùå Fail if vulnerable or scan failed
        if: steps.scan.outputs.vulnerable == 'true' || steps.scan.outputs.scan_status == 'failed'
        run: |
          if [ "${{ steps.scan.outputs.scan_status }}" == "failed" ]; then
            echo "‚ùå Escaneo de seguridad fall√≥ - Pipeline bloqueado"
            echo "No se pudo completar el an√°lisis ML"
          else
            echo "‚ùå Vulnerabilidades detectadas - Pipeline fallido"
            echo "El c√≥digo NO puede ser mergeado"
          fi
          exit 1

  unit-tests:
    name: üß™ Unit Tests
    needs: security-analysis
    runs-on: ubuntu-latest
    if: success()
    
    strategy:
      matrix:
        component: [cliente, servidor]
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: ${{ matrix.component }}/package-lock.json
      
      - name: üì¶ Install dependencies
        run: |
          cd ${{ matrix.component }}
          npm ci
      
      - name: üß™ Run tests
        run: |
          cd ${{ matrix.component }}
          npm test -- --coverage --watchAll=false || echo "No tests configured"
      
      - name: üè∑Ô∏è Add label - Tests Failed
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['tests-failed', 'needs-fix']
            });
      
      - name: üì± Notify test failure
        if: failure()
        run: |
          MESSAGE="‚ùå TESTS FALLIDOS%0A%0A"
          MESSAGE+="Repositorio: ${{ github.repository }}%0A"
          MESSAGE+="Componente: ${{ matrix.component }}%0A"
          MESSAGE+="PR: #${{ github.event.pull_request.number }}%0A"
          MESSAGE+="Autor: ${{ github.event.pull_request.user.login }}%0A%0A"
          MESSAGE+="‚ö†Ô∏è Los tests unitarios fallaron%0A"
          MESSAGE+="El c√≥digo NO puede ser mergeado%0A%0A"
          MESSAGE+="Ver logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML"

  merge-approval:
    name: ‚úÖ Merge Approval
    needs: [security-analysis, unit-tests]
    runs-on: ubuntu-latest
    if: success() && github.base_ref == 'test'
    
    steps:
      - name: ‚úÖ Approve merge to test
        run: |
          echo "‚úÖ Todos los checks pasaron"
          echo "El c√≥digo puede ser mergeado a test"
      
      - name: üì± Notify approval
        run: |
          MESSAGE="‚úÖ APROBADO PARA MERGE%0A%0A"
          MESSAGE+="PR: #${{ github.event.pull_request.number }}%0A"
          MESSAGE+="Destino: ${{ github.base_ref }}%0A"
          MESSAGE+="‚úÖ Security: PASS%0A"
          MESSAGE+="‚úÖ Tests: PASS%0A%0A"
          MESSAGE+="El c√≥digo puede ser mergeado.%0A"
          MESSAGE+="Ver PR: ${{ github.event.pull_request.html_url }}"
          
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}"
